üß© 1Ô∏è‚É£ WAP to initialise the members of a structure using a pointer to the structure
#include <stdio.h>

struct Student {
    int id;
    char name[20];
};

int main() {
    struct Student s1;            // Structure variable
    struct Student *ptr = &s1;    // Pointer to structure

    // Initializing using pointer
    ptr->id = 101;
    printf("Enter name: ");
    scanf("%s", ptr->name);

    // Display
    printf("\nStudent ID: %d", ptr->id);
    printf("\nStudent Name: %s", ptr->name);

    return 0;
}


‚úÖ Explanation:

ptr->id and ptr->name are used instead of s1.id and s1.name.

-> operator is used to access structure members via pointer.

üíæ 2Ô∏è‚É£ Using malloc() for dynamic integer array
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *arr, n, i;

    printf("Enter number of elements: ");
    scanf("%d", &n);

    arr = (int *)malloc(n * sizeof(int));  // Allocate memory

    if (arr == NULL) {   // Check if allocation successful
        printf("Memory allocation failed!\n");
        return 1;
    }

    printf("Enter %d elements:\n", n);
    for (i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    printf("Elements are:\n");
    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }

    free(arr);  // Deallocate memory
    return 0;
}


‚úÖ Explanation:

malloc() allocates memory but doesn‚Äôt initialize it.

Always check if arr == NULL before using it.

üì¶ 3Ô∏è‚É£ Using calloc() for dynamic integer array
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *arr, n, i;

    printf("Enter number of elements: ");
    scanf("%d", &n);

    arr = (int *)calloc(n, sizeof(int));  // Allocate and initialize to 0

    if (arr == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }

    printf("Enter %d elements:\n", n);
    for (i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    printf("Elements are:\n");
    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }

    free(arr);
    return 0;
}


‚úÖ Explanation:

calloc() automatically sets all bytes to zero.

Used for initializing arrays easily.

üîÅ 4Ô∏è‚É£ Using realloc() to change memory size
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *arr, n, new_n, i;

    printf("Enter initial number of elements: ");
    scanf("%d", &n);

    arr = (int *)malloc(n * sizeof(int));

    if (arr == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }

    printf("Enter %d elements:\n", n);
    for (i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    printf("Enter new size of array: ");
    scanf("%d", &new_n);

    arr = (int *)realloc(arr, new_n * sizeof(int));  // Resize memory

    if (arr == NULL) {
        printf("Reallocation failed!\n");
        return 1;
    }

    printf("Enter additional %d elements:\n", new_n - n);
    for (i = n; i < new_n; i++) {
        scanf("%d", &arr[i]);
    }

    printf("All elements:\n");
    for (i = 0; i < new_n; i++) {
        printf("%d ", arr[i]);
    }

    free(arr);
    return 0;
}


‚úÖ Explanation:

realloc() is used to increase/decrease memory size.

It keeps old data and adds more space.

‚ûï 5Ô∏è‚É£ Sum of N numbers using dynamic memory allocation
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *arr, n, i, sum = 0;

    printf("Enter number of elements: ");
    scanf("%d", &n);

    arr = (int *)malloc(n * sizeof(int));

    if (arr == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }

    printf("Enter %d numbers:\n", n);
    for (i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
        sum += arr[i];
    }

    printf("Sum = %d\n", sum);

    free(arr);  // Free memory
    return 0;
}
